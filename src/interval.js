class Interval {
    constructor(start, end) {
        this.start = start;
        this.end = end
    }

    /*toString() {
        return "[" + this.start + "," + this.end + "]";
    }*/

    /**
     * Exemple 1 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.overlaps(interval2) => true
     *
     * Exemple 2 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                                       ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.overlaps(interval2) => false
     *
     * @param {Interval} interval
     * @returns {boolean}
     */
    overlaps(interval) {
        return this.end > interval.start && this.start < interval.end;
    }

    /**
     * Retourne true si cet interval contient le paramètre interval
     *
     * Exemple 1 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                  ▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.includes(interval2) => true
     *
     * Exemple 2 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                              ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.includes(interval2) => false
     *
     * @param {Interval} interval
     * @returns {boolean}
     */
    includes(interval) {
        return this.start < interval.start && this.end > interval.end;
    };

    /**
     * Retourne l'union de deux intervals
     *
     * Exemple 1 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                              ▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.union(interval2) =>        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
     *
     * Exemple 2 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.union(interval2) =>        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
     *
     * @param {Interval} interval
     * @returns {Interval[]}
     */
    union(interval) {
        var union = [];
        if(this.overlaps(interval)){
            if (this.start < interval.start){
                if(this.end >= interval.end){
                    union.push(new Interval(this.start,(this.end))); 
                }else {
                    union.push(new Interval(this.start,(interval.end))); 
                }
            }else{
                if(this.end >= interval.end){
                    union.push(new Interval(interval.start,(this.end))); 
                }else {
                    union.push(new Interval(interval.start,(interval.end))); 
                }
            }
        }else{
            if (this.start < interval.start && this.end < interval.end){
                union.push(this, interval);
            }else {
                union.push(interval, this)
            }
        }
        return union; 
    };

    /**
     * Retourne l'intersection de deux intervals
     *
     * Exemple 1 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                              ▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.intersection(interval2) =>                     ▒▒▒▒▒
     *
     * Exemple 2 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.intersection(interval2) => <tableau vide>
     *
     * @param {Interval} interval
     * @returns {Interval|null}
     */
    intersection(interval) {
        var inter = [];
        var start = 0;
        var end = 0;
        if(this.overlaps(interval)){
            if (this.start >= interval.start)
                start = this.start;
            else {
                start = interval.start;
            }
            if(this.end <= interval.end){
                end = this.end;
            }else{
                end = interval.end;
            }
            inter.push(new Interval(start,end));
        }

        return inter;
    };

    /**
     * Retourne l'exclusion de deux intervals
     *
     * Exemple 1 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                              ▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.exclusion(interval2) =>    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒     ▒▒▒▒▒▒▒▒
     *
     * Exemple 2 :
     *      interval1 =                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval2 =                                                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
     *      interval1.exclusion(interval2) =>    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
     *
     * @param {Interval} interval
     * @returns {Interval[]}
     */
    exclusion(interval) {
        var exclu = [];
        var start_1 = 0;
        var end_2 = 0;
        var start_2 = 0;
        var end_1 = 0;
        if((this.start < interval.start && this.end > interval.end) || (interval.start < this.start && interval.end > this.end)) {
            if(this.start < interval.start) {
                start_1 = this.start;
                end_1 = interval.start;
                start_2 = interval.end;
                end_2 = this.end;
            }
            else {
                start_1 = interval.start;
                end_1 = this.start;
                start_2 = this.end;
                end_2 = interval.end;
            }
        exclu.push(new Interval(start_1, end_1),new Interval(start_2,end_2));
        }else if(this.overlaps(interval) && this.includes(interval) == false){
            if(this.start < interval.start) {
                start_1 = this.start;
                end_1 = interval.start;
                start_2 = this.end;
                end_2 = interval.end;
            }
            else {
                start_1 = interval.start;
                end_1 = this.start;
                start_2 = interval.end;
                end_2 = this.end;
            }
            exclu.push(new Interval(start_1, end_1),new Interval(start_2,end_2));
        }else{
            if (this.start < interval.start && this.end < interval.end){
                exclu.push(this, interval);
            }else {
                exclu.push(interval, this)
            }
        }
        return exclu;
    };
};


module.exports = Interval;
